<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fastapi on SATHEE</title>
    <link>/fastapi/</link>
    <description>Recent content in Fastapi on SATHEE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/fastapi/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Tutorial - User Guide - Intro </title>
      <link>/fastapi/tutorial-user-guide-intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/tutorial-user-guide-intro/</guid>
      <description>Tutorial - User Guide - Intro This tutorial shows you how to use FastAPI with most of its features, step by step.
Each section gradually builds on the previous ones, but it&#39;s structured to separate topics, so that you can go directly to any specific one to solve your specific API needs.
It is also built to work as a future reference.
So you can come back and see exactly what you need.</description>
    </item>
    
    <item>
      <title>First Steps </title>
      <link>/fastapi/first-steps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/first-steps/</guid>
      <description>First Steps The simplest FastAPI file could look like this:
from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/&amp;quot;) async def root(): return {&amp;quot;message&amp;quot;: &amp;quot;Hello World&amp;quot;} Copy that to a file main.py.
Run the live server:
$ uvicorn main:app --reload INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [28720] INFO: Started server process [28722] INFO: Waiting for application startup. INFO: Application startup complete. Note
The command uvicorn main:app refers to:</description>
    </item>
    
    <item>
      <title>Path Parameters </title>
      <link>/fastapi/path-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/path-parameters/</guid>
      <description>Path Parameters You can declare path &amp;quot;parameters&amp;quot; or &amp;quot;variables&amp;quot; with the same syntax used by Python format strings:
from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/items/{item_id}&amp;quot;) async def read_item(item_id): return {&amp;quot;item_id&amp;quot;: item_id} The value of the path parameter item_id will be passed to your function as the argument item_id.
So, if you run this example and go to http://127.0.0.1:8000/items/foo, you will see a response of:
{&amp;quot;item_id&amp;quot;:&amp;quot;foo&amp;quot;} Path parameters with types You can declare the type of a path parameter in the function, using standard Python type annotations:</description>
    </item>
    
    <item>
      <title>Query Parameters </title>
      <link>/fastapi/query-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/query-parameters/</guid>
      <description>Query Parameters When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as &amp;quot;query&amp;quot; parameters.
from fastapi import FastAPI app = FastAPI() fake_items_db = [{&amp;quot;item_name&amp;quot;: &amp;quot;Foo&amp;quot;}, {&amp;quot;item_name&amp;quot;: &amp;quot;Bar&amp;quot;}, {&amp;quot;item_name&amp;quot;: &amp;quot;Baz&amp;quot;}] @app.get(&amp;quot;/items/&amp;quot;) async def read_item(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] The query is the set of key-value pairs that go after the ? in a URL, separated by &amp;amp; characters.</description>
    </item>
    
    <item>
      <title>Request Body </title>
      <link>/fastapi/request-body/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/request-body/</guid>
      <description>Request Body When you need to send data from a client (let&#39;s say, a browser) to your API, you send it as a request body.
A request body is data sent by the client to your API. A response body is the data your API sends to the client.
Your API almost always has to send a response body. But clients don&#39;t necessarily need to send request bodies all the time.</description>
    </item>
    
    <item>
      <title>Query Parameters and String Validations </title>
      <link>/fastapi/query-parameters-and-string-validations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/query-parameters-and-string-validations/</guid>
      <description>Query Parameters and String Validations FastAPI allows you to declare additional information and validation for your parameters.
Let&#39;s take this application as example:
from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(q: str | None = None): results = {&amp;quot;items&amp;quot;: [{&amp;quot;item_id&amp;quot;: &amp;quot;Foo&amp;quot;}, {&amp;quot;item_id&amp;quot;: &amp;quot;Bar&amp;quot;}]} if q: results.update({&amp;quot;q&amp;quot;: q}) return results from typing import Union from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(q: Union[str, None] = None): results = {&amp;quot;items&amp;quot;: [{&amp;quot;item_id&amp;quot;: &amp;quot;Foo&amp;quot;}, {&amp;quot;item_id&amp;quot;: &amp;quot;Bar&amp;quot;}]} if q: results.</description>
    </item>
    
    <item>
      <title>Query Parameters and String Validations </title>
      <link>/fastapi/query-parameters-and-string-validations-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/query-parameters-and-string-validations-/</guid>
      <description>Query Parameters and String Validations FastAPI allows you to declare additional information and validation for your parameters.
Let&#39;s take this application as example:
from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(q: str | None = None): results = {&amp;quot;items&amp;quot;: [{&amp;quot;item_id&amp;quot;: &amp;quot;Foo&amp;quot;}, {&amp;quot;item_id&amp;quot;: &amp;quot;Bar&amp;quot;}]} if q: results.update({&amp;quot;q&amp;quot;: q}) return results from typing import Union from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(q: Union[str, None] = None): results = {&amp;quot;items&amp;quot;: [{&amp;quot;item_id&amp;quot;: &amp;quot;Foo&amp;quot;}, {&amp;quot;item_id&amp;quot;: &amp;quot;Bar&amp;quot;}]} if q: results.</description>
    </item>
    
    <item>
      <title>Path Parameters and Numeric Validations </title>
      <link>/fastapi/path-parameters-and-numeric-validations-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/path-parameters-and-numeric-validations-/</guid>
      <description>Path Parameters and Numeric Validations In the same way that you can declare more validations and metadata for query parameters with Query, you can declare the same type of validations and metadata for path parameters with Path.
Import Path First, import Path from fastapi, and import Annotated:
from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(&amp;quot;/items/{item_id}&amp;quot;) async def read_items( item_id: Annotated[int, Path(title=&amp;quot;The ID of the item to get&amp;quot;)], q: Annotated[str | None, Query(alias=&amp;quot;item-query&amp;quot;)] = None, ): results = {&amp;quot;item_id&amp;quot;: item_id} if q: results.</description>
    </item>
    
    <item>
      <title>Body - Multiple Parameters </title>
      <link>/fastapi/body-multiple-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/body-multiple-parameters/</guid>
      <description>Body - Multiple Parameters Now that we have seen how to use Path and Query, let&#39;s see more advanced uses of request body declarations.
Mix Path, Query and body parameters First, of course, you can mix Path, Query and request body parameter declarations freely and FastAPI will know what to do.
And you can also declare body parameters as optional, by setting the default to None:
from typing import Annotated from fastapi import FastAPI, Path from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.</description>
    </item>
    
    <item>
      <title>Body - Fields </title>
      <link>/fastapi/body-fields/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/body-fields/</guid>
      <description>Body - Fields The same way you can declare additional validation and metadata in path operation function parameters with Query, Path and Body, you can declare validation and metadata inside of Pydantic models using Pydantic&#39;s Field.
Import Field First, you have to import it:
from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI() class Item(BaseModel): name: str description: str | None = Field( default=None, title=&amp;quot;The description of the item&amp;quot;, max_length=300 ) price: float = Field(gt=0, description=&amp;quot;The price must be greater than zero&amp;quot;) tax: float | None = None @app.</description>
    </item>
    
    <item>
      <title>Body - Nested Models </title>
      <link>/fastapi/body-nested-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/body-nested-models/</guid>
      <description>Body - Nested Models With FastAPI, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).
List fields You can define an attribute to be a subtype. For example, a Python list:
from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = [] @app.put(&amp;quot;/items/{item_id}&amp;quot;) async def update_item(item_id: int, item: Item): results = {&amp;quot;item_id&amp;quot;: item_id, &amp;quot;item&amp;quot;: item} return results from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: list = [] @app.</description>
    </item>
    
    <item>
      <title>Declare Request Example Data </title>
      <link>/fastapi/declare-request-example-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/declare-request-example-data/</guid>
      <description>Declare Request Example Data You can declare examples of the data your app can receive.
Here are several ways to do it.
Pydantic schema_extra You can declare an example for a Pydantic model using Config and schema_extra, as described in Pydantic&#39;s docs: Schema customization:
from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class Config: schema_extra = { &amp;quot;example&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;Foo&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;A very nice Item&amp;quot;, &amp;quot;price&amp;quot;: 35.</description>
    </item>
    
    <item>
      <title>Declare Request Example Data </title>
      <link>/fastapi/declare-request-example-data-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/declare-request-example-data-/</guid>
      <description>Declare Request Example Data You can declare examples of the data your app can receive.
Here are several ways to do it.
Pydantic schema_extra You can declare an example for a Pydantic model using Config and schema_extra, as described in Pydantic&#39;s docs: Schema customization:
from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class Config: schema_extra = { &amp;quot;example&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;Foo&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;A very nice Item&amp;quot;, &amp;quot;price&amp;quot;: 35.</description>
    </item>
    
    <item>
      <title>Extra Data Types </title>
      <link>/fastapi/extra-data-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/extra-data-types/</guid>
      <description>Extra Data Types Up to now, you have been using common data types, like:
int
float
str
bool
But you can also use more complex data types.
And you will still have the same features as seen up to now:
Great editor support.
Data conversion from incoming requests.
Data conversion for response data.
Data validation.
Automatic annotation and documentation.
Other data types Here are some of the additional data types you can use:</description>
    </item>
    
    <item>
      <title>Cookie Parameters </title>
      <link>/fastapi/cookie-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/cookie-parameters/</guid>
      <description>Cookie Parameters You can define Cookie parameters the same way you define Query and Path parameters.
Import Cookie First import Cookie:
from typing import Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(ads_id: Annotated[str | None, Cookie()] = None): return {&amp;quot;ads_id&amp;quot;: ads_id} from typing import Annotated, Union from fastapi import Cookie, FastAPI app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None): return {&amp;quot;ads_id&amp;quot;: ads_id} from typing import Union from fastapi import Cookie, FastAPI from typing_extensions import Annotated app = FastAPI() @app.</description>
    </item>
    
    <item>
      <title>Header Parameters </title>
      <link>/fastapi/header-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/header-parameters/</guid>
      <description>Header Parameters You can define Header parameters the same way you define Query, Path and Cookie parameters.
Import Header First import Header:
from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(user_agent: Annotated[str | None, Header()] = None): return {&amp;quot;User-Agent&amp;quot;: user_agent} from typing import Annotated, Union from fastapi import FastAPI, Header app = FastAPI() @app.get(&amp;quot;/items/&amp;quot;) async def read_items(user_agent: Annotated[Union[str, None], Header()] = None): return {&amp;quot;User-Agent&amp;quot;: user_agent} from typing import Union from fastapi import FastAPI, Header from typing_extensions import Annotated app = FastAPI() @app.</description>
    </item>
    
    <item>
      <title>Response Model - Return Type </title>
      <link>/fastapi/response-model-return-type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/response-model-return-type/</guid>
      <description>Response Model - Return Type You can declare the type used for the response by annotating the path operation function return type.
You can use type annotations the same way you would for input data in function parameters, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.
from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = [] @app.</description>
    </item>
    
    <item>
      <title>Extra Models </title>
      <link>/fastapi/extra-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/extra-models/</guid>
      <description>Extra Models Continuing with the previous example, it will be common to have more than one related model.
This is especially the case for user models, because:
The input model needs to be able to have a password.
The output model should not have a password.
The database model would probably need to have a hashed password.
Danger
Never store user&#39;s plaintext passwords. Always store a &amp;quot;secure hash&amp;quot; that you can then verify.</description>
    </item>
    
    <item>
      <title>Response Status Code </title>
      <link>/fastapi/response-status-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/response-status-code/</guid>
      <description>Response Status Code The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter status_code in any of the path operations:
@app.get()
@app.post()
@app.put()
@app.delete()
etc.
from fastapi import FastAPI app = FastAPI() @app.post(&amp;quot;/items/&amp;quot;, status_code=201) async def create_item(name: str): return {&amp;quot;name&amp;quot;: name} Note
Notice that status_code is a parameter of the &amp;quot;decorator&amp;quot; method (get, post, etc). Not of your path operation function, like all the parameters and body.</description>
    </item>
    
    <item>
      <title>Form Data </title>
      <link>/fastapi/form-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/form-data/</guid>
      <description>Form Data When you need to receive form fields instead of JSON, you can use Form.
Info
To use forms, first install python-multipart.
E.g. pip install python-multipart.
Import Form Import Form from fastapi:
from typing import Annotated from fastapi import FastAPI, Form app = FastAPI() @app.post(&amp;quot;/login/&amp;quot;) async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]): return {&amp;quot;username&amp;quot;: username} from fastapi import FastAPI, Form from typing_extensions import Annotated app = FastAPI() @app.post(&amp;quot;/login/&amp;quot;) async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]): return {&amp;quot;username&amp;quot;: username} Tip</description>
    </item>
    
    <item>
      <title>Request Files </title>
      <link>/fastapi/request-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/request-files/</guid>
      <description>Request Files You can define files to be uploaded by the client using File.
Info
To receive uploaded files, first install python-multipart.
E.g. pip install python-multipart.
This is because uploaded files are sent as &amp;quot;form data&amp;quot;.
Import File Import File and UploadFile from fastapi:
from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(&amp;quot;/files/&amp;quot;) async def create_file(file: Annotated[bytes, File()]): return {&amp;quot;file_size&amp;quot;: len(file)} @app.post(&amp;quot;/uploadfile/&amp;quot;) async def create_upload_file(file: UploadFile): return {&amp;quot;filename&amp;quot;: file.</description>
    </item>
    
    <item>
      <title>Request Forms and Files </title>
      <link>/fastapi/request-forms-and-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/request-forms-and-files/</guid>
      <description>Request Forms and Files You can define files and form fields at the same time using File and Form.
Info
To receive uploaded files and/or form data, first install python-multipart.
E.g. pip install python-multipart.
Import File and Form from typing import Annotated from fastapi import FastAPI, File, Form, UploadFile app = FastAPI() @app.post(&amp;quot;/files/&amp;quot;) async def create_file( file: Annotated[bytes, File()], fileb: Annotated[UploadFile, File()], token: Annotated[str, Form()], ): return { &amp;quot;file_size&amp;quot;: len(file), &amp;quot;token&amp;quot;: token, &amp;quot;fileb_content_type&amp;quot;: fileb.</description>
    </item>
    
    <item>
      <title>Handling Errors </title>
      <link>/fastapi/handling-errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/handling-errors/</guid>
      <description>Handling Errors There are many situations in where you need to notify an error to a client that is using your API.
This client could be a browser with a frontend, a code from someone else, an IoT device, etc.
You could need to tell the client that:
The client doesn&#39;t have enough privileges for that operation.
The client doesn&#39;t have access to that resource.
The item the client was trying to access doesn&#39;t exist.</description>
    </item>
    
    <item>
      <title>Path Operation Configuration </title>
      <link>/fastapi/path-operation-configuration-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/path-operation-configuration-/</guid>
      <description>Path Operation Configuration There are several parameters that you can pass to your path operation decorator to configure it.
Warning
Notice that these parameters are passed directly to the path operation decorator, not to your path operation function.
Response Status Code You can define the (HTTP) status_code to be used in the response of your path operation.
You can pass directly the int code, like 404.
But if you don&#39;t remember what each number code is for, you can use the shortcut constants in status:</description>
    </item>
    
    <item>
      <title>JSON Compatible Encoder </title>
      <link>/fastapi/json-compatible-encoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/json-compatible-encoder/</guid>
      <description>JSON Compatible Encoder There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a dict, list, etc).
For example, if you need to store it in a database.
For that, FastAPI provides a jsonable_encoder() function.
Using the jsonable_encoder Let&#39;s imagine that you have a database fake_db that only receives JSON compatible data.
For example, it doesn&#39;t receive datetime objects, as those are not compatible with JSON.</description>
    </item>
    
    <item>
      <title>Body - Updates </title>
      <link>/fastapi/body-updates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/body-updates/</guid>
      <description>Body - Updates Update replacing with PUT To update an item you can use the HTTP PUT operation.
You can use the jsonable_encoder to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting datetime to str.
from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.</description>
    </item>
    
    <item>
      <title>Dependencies - First Steps </title>
      <link>/fastapi/dependencies-first-steps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/dependencies-first-steps/</guid>
      <description>Dependencies - First Steps FastAPI has a very powerful but intuitive Dependency Injection system.
It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with FastAPI.
What is &amp;quot;Dependency Injection&amp;quot; &amp;quot;Dependency Injection&amp;quot; means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: &amp;quot;dependencies&amp;quot;.</description>
    </item>
    
    <item>
      <title>Classes as Dependencies </title>
      <link>/fastapi/classes-as-dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/classes-as-dependencies/</guid>
      <description>Classes as Dependencies Before diving deeper into the Dependency Injection system, let&#39;s upgrade the previous example.
A dict from the previous example In the previous example, we were returning a dict from our dependency (&amp;quot;dependable&amp;quot;):
from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {&amp;quot;q&amp;quot;: q, &amp;quot;skip&amp;quot;: skip, &amp;quot;limit&amp;quot;: limit} @app.</description>
    </item>
    
    <item>
      <title>Sub-dependencies </title>
      <link>/fastapi/sub-dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/sub-dependencies/</guid>
      <description>Sub-dependencies You can create dependencies that have sub-dependencies.
They can be as deep as you need them to be.
FastAPI will take care of solving them.
First dependency &amp;quot;dependable&amp;quot; You could create a first dependency (&amp;quot;dependable&amp;quot;) like:
from typing import Annotated from fastapi import Cookie, Depends, FastAPI app = FastAPI() def query_extractor(q: str | None = None): return q def query_or_cookie_extractor( q: Annotated[str, Depends(query_extractor)], last_query: Annotated[str | None, Cookie()] = None, ): if not q: return last_query return q @app.</description>
    </item>
    
    <item>
      <title>Dependencies in path operation decorators </title>
      <link>/fastapi/dependencies-in-path-operation-decorators-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/dependencies-in-path-operation-decorators-/</guid>
      <description>Dependencies in path operation decorators In some cases you don&#39;t really need the return value of a dependency inside your path operation function.
Or the dependency doesn&#39;t return a value.
But you still need it to be executed/solved.
For those cases, instead of declaring a path operation function parameter with Depends, you can add a list of dependencies to the path operation decorator.
Add dependencies to the path operation decorator The path operation decorator receives an optional argument dependencies.</description>
    </item>
    
    <item>
      <title>Global Dependencies </title>
      <link>/fastapi/global-dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/global-dependencies/</guid>
      <description>Global Dependencies For some types of applications you might want to add dependencies to the whole application.
Similar to the way you can add dependencies to the path operation decorators, you can add them to the FastAPI application.
In that case, they will be applied to all the path operations in the application:
from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated async def verify_token(x_token: Annotated[str, Header()]): if x_token !</description>
    </item>
    
    <item>
      <title>Dependencies with yield </title>
      <link>/fastapi/dependencies-with-yield/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/dependencies-with-yield/</guid>
      <description>Dependencies with yield FastAPI supports dependencies that do some extra steps after finishing.
To do this, use yield instead of return, and write the extra steps after.
Tip
Make sure to use yield one single time.
Technical Details
Any function that is valid to use with:
@contextlib.contextmanager or
@contextlib.asynccontextmanager
would be valid to use as a FastAPI dependency.
In fact, FastAPI uses those two decorators internally.
A database dependency with yield For example, you could use this to create a database session and close it after finishing.</description>
    </item>
    
    <item>
      <title>Security Intro </title>
      <link>/fastapi/security-intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/security-intro/</guid>
      <description>Security Intro There are many ways to handle security, authentication and authorization.
And it normally is a complex and &amp;quot;difficult&amp;quot; topic.
In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).
FastAPI provides several tools to help you deal with Security easily, rapidly, in a standard way, without having to study and learn all the security specifications.</description>
    </item>
    
    <item>
      <title>Security - First Steps </title>
      <link>/fastapi/security-first-steps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/security-first-steps/</guid>
      <description>Security - First Steps Let&#39;s imagine that you have your backend API in some domain.
And you have a frontend in another domain or in a different path of the same domain (or in a mobile application).
And you want to have a way for the frontend to authenticate with the backend, using a username and password.
We can use OAuth2 to build that with FastAPI.
But let&#39;s save you the time of reading the full long specification just to find those little pieces of information you need.</description>
    </item>
    
    <item>
      <title>Get Current User </title>
      <link>/fastapi/get-current-user/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/get-current-user/</guid>
      <description>Get Current User In the previous chapter the security system (which is based on the dependency injection system) was giving the path operation function a token as a str:
from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI() oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&amp;quot;token&amp;quot;) @app.get(&amp;quot;/items/&amp;quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]): return {&amp;quot;token&amp;quot;: token} from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from typing_extensions import Annotated app = FastAPI() oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&amp;quot;token&amp;quot;) @app.</description>
    </item>
    
    <item>
      <title>Simple OAuth2 with Password and Bearer </title>
      <link>/fastapi/simple-oauth2-with-password-and-bearer-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/simple-oauth2-with-password-and-bearer-/</guid>
      <description>Simple OAuth2 with Password and Bearer Now let&#39;s build from the previous chapter and add the missing parts to have a complete security flow.
Get the username and password We are going to use FastAPI security utilities to get the username and password.
OAuth2 specifies that when using the &amp;quot;password flow&amp;quot; (that we are using) the client/user must send a username and password fields as form data.
And the spec says that the fields have to be named like that.</description>
    </item>
    
    <item>
      <title>OAuth2 with Password (and hashing), Bearer with JWT tokens </title>
      <link>/fastapi/oauth2-with-password-and-hashing-bearer-with-jwt-tokens-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/oauth2-with-password-and-hashing-bearer-with-jwt-tokens-/</guid>
      <description>OAuth2 with Password (and hashing), Bearer with JWT tokens Now that we have all the security flow, let&#39;s make the application actually secure, using JWT tokens and secure password hashing.
This code is something you can actually use in your application, save the password hashes in your database, etc.
We are going to start from where we left in the previous chapter and increment it.
About JWT JWT means &amp;quot;JSON Web Tokens&amp;quot;.</description>
    </item>
    
    <item>
      <title>Middleware </title>
      <link>/fastapi/middleware/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/middleware/</guid>
      <description>Middleware You can add middleware to FastAPI applications.
A &amp;quot;middleware&amp;quot; is a function that works with every request before it is processed by any specific path operation. And also with every response before returning it.
It takes each request that comes to your application.
It can then do something to that request or run any needed code.
Then it passes the request to be processed by the rest of the application (by some path operation).</description>
    </item>
    
    <item>
      <title>CORS (Cross-Origin Resource Sharing) </title>
      <link>/fastapi/cors-cross-origin-resource-sharing-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/cors-cross-origin-resource-sharing-/</guid>
      <description>CORS (Cross-Origin Resource Sharing) CORS or &amp;quot;Cross-Origin Resource Sharing&amp;quot; refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different &amp;quot;origin&amp;quot; than the frontend.
Origin An origin is the combination of protocol (http, https), domain (myapp.com, localhost, localhost.tiangolo.com), and port (80, 443, 8080).
So, all these are different origins:
http://localhost
https://localhost
http://localhost:8080
Even if they are all in localhost, they use different protocols or ports, so, they are different &amp;quot;origins&amp;quot;.</description>
    </item>
    
    <item>
      <title>SQL (Relational) Databases </title>
      <link>/fastapi/sql-relational-databases-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/sql-relational-databases-/</guid>
      <description>SQL (Relational) Databases FastAPI doesn&#39;t require you to use a SQL (relational) database.
But you can use any relational database that you want.
Here we&#39;ll see an example using SQLAlchemy.
You can easily adapt it to any database supported by SQLAlchemy, like:
PostgreSQL
MySQL
SQLite
Oracle
Microsoft SQL Server, etc.
In this example, we&#39;ll use SQLite, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.</description>
    </item>
    
    <item>
      <title>Bigger Applications - Multiple Files </title>
      <link>/fastapi/bigger-applications-multiple-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/bigger-applications-multiple-files/</guid>
      <description>Bigger Applications - Multiple Files If you are building an application or a web API, it&#39;s rarely the case that you can put everything on a single file.
FastAPI provides a convenience tool to structure your application while keeping all the flexibility.
Info
If you come from Flask, this would be the equivalent of Flask&#39;s Blueprints.
An example file structure Let&#39;s say you have a file structure like this:
. ├── app │ ├── __init__.</description>
    </item>
    
    <item>
      <title>Background Tasks </title>
      <link>/fastapi/background-tasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/background-tasks/</guid>
      <description>Background Tasks You can define background tasks to be run after returning a response.
This is useful for operations that need to happen after a request, but that the client doesn&#39;t really have to be waiting for the operation to complete before receiving the response.
This includes, for example:
Email notifications sent after performing an action: As connecting to an email server and sending an email tends to be &amp;quot;slow&amp;quot; (several seconds), you can return the response right away and send the email notification in the background.</description>
    </item>
    
    <item>
      <title>Metadata and Docs URLs </title>
      <link>/fastapi/metadata-and-docs-urls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/metadata-and-docs-urls/</guid>
      <description>Metadata and Docs URLs You can customize several metadata configurations in your FastAPI application.
Metadata for API You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs:
Parameter Type Description title str The title of the API. description str A short description of the API. It can use Markdown. version string The version of the API. This is the version of your own application, not of OpenAPI.</description>
    </item>
    
    <item>
      <title>Static Files </title>
      <link>/fastapi/static-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/static-files/</guid>
      <description>Static Files You can serve static files automatically from a directory using StaticFiles.
Use StaticFiles Import StaticFiles.
&amp;quot;Mount&amp;quot; a StaticFiles() instance in a specific path.
from fastapi import FastAPI from fastapi.staticfiles import StaticFiles app = FastAPI() app.mount(&amp;quot;/static&amp;quot;, StaticFiles(directory=&amp;quot;static&amp;quot;), name=&amp;quot;static&amp;quot;) Technical Details
You could also use from starlette.staticfiles import StaticFiles.
FastAPI provides the same starlette.staticfiles as fastapi.staticfiles just as a convenience for you, the developer. But it actually comes directly from Starlette.</description>
    </item>
    
    <item>
      <title>Testing </title>
      <link>/fastapi/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/testing/</guid>
      <description>Testing Thanks to Starlette, testing FastAPI applications is easy and enjoyable.
It is based on HTTPX, which in turn is designed based on Requests, so it&#39;s very familiar and intuitive.
With it, you can use pytest directly with FastAPI.
Using TestClient Info
To use TestClient, first install httpx.
E.g. pip install httpx.
Import TestClient.
Create a TestClient by passing your FastAPI application to it.
Create functions with a name that starts with test_ (this is standard pytest conventions).</description>
    </item>
    
    <item>
      <title>Debugging </title>
      <link>/fastapi/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/fastapi/debugging/</guid>
      <description>Debugging You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm.
Call uvicorn In your FastAPI application, import and run uvicorn directly:
import uvicorn from fastapi import FastAPI app = FastAPI() @app.get(&amp;quot;/&amp;quot;) def root(): a = &amp;quot;a&amp;quot; b = &amp;quot;b&amp;quot; + a return {&amp;quot;hello world&amp;quot;: b} if __name__ == &amp;quot;__main__&amp;quot;: uvicorn.run(app, host=&amp;quot;0.0.0.0&amp;quot;, port=8000) About __name__ == &amp;quot;__main__&amp;quot; The main purpose of the __name__ == &amp;quot;__main__&amp;quot; is to have some code that is executed when your file is called with:</description>
    </item>
    
    
  </channel>
</rss>
